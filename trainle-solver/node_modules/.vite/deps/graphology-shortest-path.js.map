{
  "version": 3,
  "sources": ["../../graphology-utils/is-graph.js", "../../obliterator/foreach.js", "../../mnemonist/queue.js", "../../@yomguithereal/helpers/extend.js", "../../graphology-shortest-path/unweighted.js", "../../graphology-shortest-path/utils.js", "../../graphology-utils/getters.js", "../../mnemonist/utils/comparators.js", "../../mnemonist/utils/typed-arrays.js", "../../mnemonist/utils/iterables.js", "../../mnemonist/heap.js", "../../graphology-shortest-path/dijkstra.js", "../../graphology-shortest-path/index.js"],
  "sourcesContent": ["/**\n * Graphology isGraph\n * ===================\n *\n * Very simple function aiming at ensuring the given variable is a\n * graphology instance.\n */\n\n/**\n * Checking the value is a graphology instance.\n *\n * @param  {any}     value - Target value.\n * @return {boolean}\n */\nmodule.exports = function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function' &&\n    typeof value.multi === 'boolean'\n  );\n};\n", "/**\n * Obliterator ForEach Function\n * =============================\n *\n * Helper function used to easily iterate over mixed values.\n */\nvar support = require('./support.js');\n\nvar ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;\nvar SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;\n\n/**\n * Function able to iterate over almost any iterable JS value.\n *\n * @param  {any}      iterable - Iterable value.\n * @param  {function} callback - Callback function.\n */\nmodule.exports = function forEach(iterable, callback) {\n  var iterator, k, i, l, s;\n\n  if (!iterable) throw new Error('obliterator/forEach: invalid iterable.');\n\n  if (typeof callback !== 'function')\n    throw new Error('obliterator/forEach: expecting a callback.');\n\n  // The target is an array or a string or function arguments\n  if (\n    Array.isArray(iterable) ||\n    (ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable)) ||\n    typeof iterable === 'string' ||\n    iterable.toString() === '[object Arguments]'\n  ) {\n    for (i = 0, l = iterable.length; i < l; i++) callback(iterable[i], i);\n    return;\n  }\n\n  // The target has a #.forEach method\n  if (typeof iterable.forEach === 'function') {\n    iterable.forEach(callback);\n    return;\n  }\n\n  // The target is iterable\n  if (\n    SYMBOL_SUPPORT &&\n    Symbol.iterator in iterable &&\n    typeof iterable.next !== 'function'\n  ) {\n    iterable = iterable[Symbol.iterator]();\n  }\n\n  // The target is an iterator\n  if (typeof iterable.next === 'function') {\n    iterator = iterable;\n    i = 0;\n\n    while (((s = iterator.next()), s.done !== true)) {\n      callback(s.value, i);\n      i++;\n    }\n\n    return;\n  }\n\n  // The target is a plain object\n  for (k in iterable) {\n    if (iterable.hasOwnProperty(k)) {\n      callback(iterable[k], k);\n    }\n  }\n\n  return;\n};\n", "/**\n * Mnemonist Queue\n * ================\n *\n * Queue implementation based on the ideas of Queue.js that seems to beat\n * a LinkedList one in performance.\n */\nvar Iterator = require('obliterator/iterator'),\n    forEach = require('obliterator/foreach');\n\n/**\n * Queue\n *\n * @constructor\n */\nfunction Queue() {\n  this.clear();\n}\n\n/**\n * Method used to clear the queue.\n *\n * @return {undefined}\n */\nQueue.prototype.clear = function() {\n\n  // Properties\n  this.items = [];\n  this.offset = 0;\n  this.size = 0;\n};\n\n/**\n * Method used to add an item to the queue.\n *\n * @param  {any}    item - Item to enqueue.\n * @return {number}\n */\nQueue.prototype.enqueue = function(item) {\n\n  this.items.push(item);\n  return ++this.size;\n};\n\n/**\n * Method used to retrieve & remove the first item of the queue.\n *\n * @return {any}\n */\nQueue.prototype.dequeue = function() {\n  if (!this.size)\n    return;\n\n  var item = this.items[this.offset];\n\n  if (++this.offset * 2 >= this.items.length) {\n    this.items = this.items.slice(this.offset);\n    this.offset = 0;\n  }\n\n  this.size--;\n\n  return item;\n};\n\n/**\n * Method used to retrieve the first item of the queue.\n *\n * @return {any}\n */\nQueue.prototype.peek = function() {\n  if (!this.size)\n    return;\n\n  return this.items[this.offset];\n};\n\n/**\n * Method used to iterate over the queue.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nQueue.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  for (var i = this.offset, j = 0, l = this.items.length; i < l; i++, j++)\n    callback.call(scope, this.items[i], j, this);\n};\n\n/*\n * Method used to convert the queue to a JavaScript array.\n *\n * @return {array}\n */\nQueue.prototype.toArray = function() {\n  return this.items.slice(this.offset);\n};\n\n/**\n * Method used to create an iterator over a queue's values.\n *\n * @return {Iterator}\n */\nQueue.prototype.values = function() {\n  var items = this.items,\n      i = this.offset;\n\n  return new Iterator(function() {\n    if (i >= items.length)\n      return {\n        done: true\n      };\n\n    var value = items[i];\n    i++;\n\n    return {\n      value: value,\n      done: false\n    };\n  });\n};\n\n/**\n * Method used to create an iterator over a queue's entries.\n *\n * @return {Iterator}\n */\nQueue.prototype.entries = function() {\n  var items = this.items,\n      i = this.offset,\n      j = 0;\n\n  return new Iterator(function() {\n    if (i >= items.length)\n      return {\n        done: true\n      };\n\n    var value = items[i];\n    i++;\n\n    return {\n      value: [j++, value],\n      done: false\n    };\n  });\n};\n\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  Queue.prototype[Symbol.iterator] = Queue.prototype.values;\n\n/**\n * Convenience known methods.\n */\nQueue.prototype.toString = function() {\n  return this.toArray().join(',');\n};\n\nQueue.prototype.toJSON = function() {\n  return this.toArray();\n};\n\nQueue.prototype.inspect = function() {\n  var array = this.toArray();\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(array, 'constructor', {\n    value: Queue,\n    enumerable: false\n  });\n\n  return array;\n};\n\nif (typeof Symbol !== 'undefined')\n  Queue.prototype[Symbol.for('nodejs.util.inspect.custom')] = Queue.prototype.inspect;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a queue.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @return {Queue}\n */\nQueue.from = function(iterable) {\n  var queue = new Queue();\n\n  forEach(iterable, function(value) {\n    queue.enqueue(value);\n  });\n\n  return queue;\n};\n\n/**\n * Static @.of function taking an arbitrary number of arguments & converting it\n * into a queue.\n *\n * @param  {...any} args\n * @return {Queue}\n */\nQueue.of = function() {\n  return Queue.from(arguments);\n};\n\n/**\n * Exporting.\n */\nmodule.exports = Queue;\n", "/**\n * Extend function\n * ================\n *\n * Function used to push a bunch of values into an array at once.\n *\n * Its strategy is to mutate target array's length then setting the new indices\n * to be the values to add.\n *\n * A benchmark proved that it is faster than the following strategies:\n *   1) `array.push.apply(array, values)`.\n *   2) A loop of pushes.\n *   3) `array = array.concat(values)`, obviously.\n *\n * Intuitively, this is correct because when adding a lot of elements, the\n * chosen strategies does not need to handle the `arguments` object to\n * execute #.apply's variadicity and because the array know its final length\n * at the beginning, avoiding potential multiple reallocations of the underlying\n * contiguous array. Some engines may be able to optimize the loop of push\n * operations but empirically they don't seem to do so.\n */\n\n/**\n * Extends the target array with the given values.\n *\n * @param  {array} array  - Target array.\n * @param  {array} values - Values to add.\n */\nmodule.exports = function extend(array, values) {\n  var l2 = values.length;\n\n  if (l2 === 0)\n    return;\n\n  var l1 = array.length;\n\n  array.length += l2;\n\n  for (var i = 0; i < l2; i++)\n    array[l1 + i] = values[i];\n};\n", "/**\n * Graphology Unweighted Shortest Path\n * ====================================\n *\n * Basic algorithms to find the shortest paths between nodes in a graph\n * whose edges are not weighted.\n */\nvar isGraph = require('graphology-utils/is-graph');\nvar Queue = require('mnemonist/queue');\nvar extend = require('@yomguithereal/helpers/extend');\n\n/**\n * Function attempting to find the shortest path in a graph between\n * given source & target or `null` if such a path does not exist.\n *\n * @param  {Graph}      graph  - Target graph.\n * @param  {any}        source - Source node.\n * @param  {any}        target - Target node.\n * @return {array|null}        - Found path or `null`.\n */\nfunction bidirectional(graph, source, target) {\n  if (!isGraph(graph))\n    throw new Error('graphology-shortest-path: invalid graphology instance.');\n\n  if (arguments.length < 3)\n    throw new Error(\n      'graphology-shortest-path: invalid number of arguments. Expecting at least 3.'\n    );\n\n  if (!graph.hasNode(source))\n    throw new Error(\n      'graphology-shortest-path: the \"' +\n        source +\n        '\" source node does not exist in the given graph.'\n    );\n\n  if (!graph.hasNode(target))\n    throw new Error(\n      'graphology-shortest-path: the \"' +\n        target +\n        '\" target node does not exist in the given graph.'\n    );\n\n  source = '' + source;\n  target = '' + target;\n\n  // TODO: do we need a self loop to go there?\n  if (source === target) {\n    return [source];\n  }\n\n  // Binding functions\n  var getPredecessors = graph.inboundNeighbors.bind(graph),\n    getSuccessors = graph.outboundNeighbors.bind(graph);\n\n  var predecessor = {},\n    successor = {};\n\n  // Predecessor & successor\n  predecessor[source] = null;\n  successor[target] = null;\n\n  // Fringes\n  var forwardFringe = [source],\n    reverseFringe = [target],\n    currentFringe,\n    node,\n    neighbors,\n    neighbor,\n    i,\n    j,\n    l,\n    m;\n\n  var found = false;\n\n  outer: while (forwardFringe.length && reverseFringe.length) {\n    if (forwardFringe.length <= reverseFringe.length) {\n      currentFringe = forwardFringe;\n      forwardFringe = [];\n\n      for (i = 0, l = currentFringe.length; i < l; i++) {\n        node = currentFringe[i];\n        neighbors = getSuccessors(node);\n\n        for (j = 0, m = neighbors.length; j < m; j++) {\n          neighbor = neighbors[j];\n\n          if (!(neighbor in predecessor)) {\n            forwardFringe.push(neighbor);\n            predecessor[neighbor] = node;\n          }\n\n          if (neighbor in successor) {\n            // Path is found!\n            found = true;\n            break outer;\n          }\n        }\n      }\n    } else {\n      currentFringe = reverseFringe;\n      reverseFringe = [];\n\n      for (i = 0, l = currentFringe.length; i < l; i++) {\n        node = currentFringe[i];\n        neighbors = getPredecessors(node);\n\n        for (j = 0, m = neighbors.length; j < m; j++) {\n          neighbor = neighbors[j];\n\n          if (!(neighbor in successor)) {\n            reverseFringe.push(neighbor);\n            successor[neighbor] = node;\n          }\n\n          if (neighbor in predecessor) {\n            // Path is found!\n            found = true;\n            break outer;\n          }\n        }\n      }\n    }\n  }\n\n  if (!found) return null;\n\n  var path = [];\n\n  while (neighbor) {\n    path.unshift(neighbor);\n    neighbor = predecessor[neighbor];\n  }\n\n  neighbor = successor[path[path.length - 1]];\n\n  while (neighbor) {\n    path.push(neighbor);\n    neighbor = successor[neighbor];\n  }\n\n  return path.length ? path : null;\n}\n\n/**\n * Function attempting to find the shortest path in the graph between the\n * given source node & all the other nodes.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @return {object}        - The map of found paths.\n */\n\n// TODO: cutoff option\nfunction singleSource(graph, source) {\n  if (!isGraph(graph))\n    throw new Error('graphology-shortest-path: invalid graphology instance.');\n\n  if (arguments.length < 2)\n    throw new Error(\n      'graphology-shortest-path: invalid number of arguments. Expecting at least 2.'\n    );\n\n  if (!graph.hasNode(source))\n    throw new Error(\n      'graphology-shortest-path: the \"' +\n        source +\n        '\" source node does not exist in the given graph.'\n    );\n\n  source = '' + source;\n\n  var nextLevel = {},\n    paths = {},\n    currentLevel,\n    neighbors,\n    v,\n    w,\n    i,\n    l;\n\n  nextLevel[source] = true;\n  paths[source] = [source];\n\n  while (Object.keys(nextLevel).length) {\n    currentLevel = nextLevel;\n    nextLevel = {};\n\n    for (v in currentLevel) {\n      neighbors = graph.outboundNeighbors(v);\n\n      for (i = 0, l = neighbors.length; i < l; i++) {\n        w = neighbors[i];\n\n        if (!paths[w]) {\n          paths[w] = paths[v].concat(w);\n          nextLevel[w] = true;\n        }\n      }\n    }\n  }\n\n  return paths;\n}\n\n/**\n * Function attempting to find the shortest path lengths in the graph between\n * the given source node & all the other nodes.\n *\n * @param  {string} method - Neighbor collection method name.\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @return {object}        - The map of found path lengths.\n */\n\n// TODO: cutoff option\nfunction asbtractSingleSourceLength(method, graph, source) {\n  if (!isGraph(graph))\n    throw new Error('graphology-shortest-path: invalid graphology instance.');\n\n  if (!graph.hasNode(source))\n    throw new Error(\n      'graphology-shortest-path: the \"' +\n        source +\n        '\" source node does not exist in the given graph.'\n    );\n\n  source = '' + source;\n\n  // Performing BFS to count shortest paths\n  var seen = new Set();\n\n  var lengths = {},\n    level = 0;\n\n  lengths[source] = 0;\n\n  var currentLevel = [source];\n\n  var i, l, node;\n\n  while (currentLevel.length !== 0) {\n    var nextLevel = [];\n\n    for (i = 0, l = currentLevel.length; i < l; i++) {\n      node = currentLevel[i];\n\n      if (seen.has(node)) continue;\n\n      seen.add(node);\n      extend(nextLevel, graph[method](node));\n\n      lengths[node] = level;\n    }\n\n    level++;\n    currentLevel = nextLevel;\n  }\n\n  return lengths;\n}\n\nvar singleSourceLength = asbtractSingleSourceLength.bind(\n  null,\n  'outboundNeighbors'\n);\nvar undirectedSingleSourceLength = asbtractSingleSourceLength.bind(\n  null,\n  'neighbors'\n);\n\n/**\n * Function using Ulrik Brandes' method to map single source shortest paths\n * from selected node.\n *\n * [Reference]:\n * Ulrik Brandes: A Faster Algorithm for Betweenness Centrality.\n * Journal of Mathematical Sociology 25(2):163-177, 2001.\n *\n * @param  {Graph}  graph      - Target graph.\n * @param  {any}    source     - Source node.\n * @return {array}             - [Stack, Paths, Sigma]\n */\nfunction brandes(graph, source) {\n  source = '' + source;\n\n  var S = [],\n    P = {},\n    sigma = {};\n\n  var nodes = graph.nodes(),\n    Dv,\n    sigmav,\n    neighbors,\n    v,\n    w,\n    i,\n    j,\n    l,\n    m;\n\n  for (i = 0, l = nodes.length; i < l; i++) {\n    v = nodes[i];\n    P[v] = [];\n    sigma[v] = 0;\n  }\n\n  var D = {};\n\n  sigma[source] = 1;\n  D[source] = 0;\n\n  var queue = Queue.of(source);\n\n  while (queue.size) {\n    v = queue.dequeue();\n    S.push(v);\n\n    Dv = D[v];\n    sigmav = sigma[v];\n\n    neighbors = graph.outboundNeighbors(v);\n\n    for (j = 0, m = neighbors.length; j < m; j++) {\n      w = neighbors[j];\n\n      if (!(w in D)) {\n        queue.enqueue(w);\n        D[w] = Dv + 1;\n      }\n\n      if (D[w] === Dv + 1) {\n        sigma[w] += sigmav;\n        P[w].push(v);\n      }\n    }\n  }\n\n  return [S, P, sigma];\n}\n\n/**\n * Exporting.\n */\nexports.bidirectional = bidirectional;\nexports.singleSource = singleSource;\nexports.singleSourceLength = singleSourceLength;\nexports.undirectedSingleSourceLength = undirectedSingleSourceLength;\nexports.brandes = brandes;\n", "/**\n * Graphology Shortest Path Utils\n * ===============================\n *\n * Miscellaneous shortest-path helper functions.\n */\nvar returnTrue = function () {\n  return true;\n};\n\nexports.edgePathFromNodePath = function (graph, nodePath) {\n  var l = nodePath.length;\n\n  var i, source, target, edge;\n\n  // Self loops\n  if (l < 2) {\n    source = nodePath[0];\n\n    edge = graph.multi\n      ? graph.findEdge(source, source, returnTrue)\n      : graph.edge(source, source);\n\n    if (edge) return [edge];\n\n    return [];\n  }\n\n  l--;\n\n  var edgePath = new Array(l);\n\n  for (i = 0; i < l; i++) {\n    source = nodePath[i];\n    target = nodePath[i + 1];\n\n    edge = graph.multi\n      ? graph.findOutboundEdge(source, target, returnTrue)\n      : graph.edge(source, target);\n\n    if (edge === undefined)\n      throw new Error(\n        'graphology-shortest-path: given path is impossible in given graph.'\n      );\n\n    edgePath[i] = edge;\n  }\n\n  return edgePath;\n};\n", "/**\n * Graphology Weight Getter\n * =========================\n *\n * Function creating weight getters.\n */\nfunction coerceWeight(value) {\n  // Ensuring target value is a correct number\n  if (typeof value !== 'number' || isNaN(value)) return 1;\n\n  return value;\n}\n\nfunction createNodeValueGetter(nameOrFunction, defaultValue) {\n  var getter = {};\n\n  var coerceToDefault = function (v) {\n    if (typeof v === 'undefined') return defaultValue;\n\n    return v;\n  };\n\n  if (typeof defaultValue === 'function') coerceToDefault = defaultValue;\n\n  var get = function (attributes) {\n    return coerceToDefault(attributes[nameOrFunction]);\n  };\n\n  var returnDefault = function () {\n    return coerceToDefault(undefined);\n  };\n\n  if (typeof nameOrFunction === 'string') {\n    getter.fromAttributes = get;\n    getter.fromGraph = function (graph, node) {\n      return get(graph.getNodeAttributes(node));\n    };\n    getter.fromEntry = function (node, attributes) {\n      return get(attributes);\n    };\n  } else if (typeof nameOrFunction === 'function') {\n    getter.fromAttributes = function () {\n      throw new Error(\n        'graphology-utils/getters/createNodeValueGetter: irrelevant usage.'\n      );\n    };\n    getter.fromGraph = function (graph, node) {\n      return coerceToDefault(\n        nameOrFunction(node, graph.getNodeAttributes(node))\n      );\n    };\n    getter.fromEntry = function (node, attributes) {\n      return coerceToDefault(nameOrFunction(node, attributes));\n    };\n  } else {\n    getter.fromAttributes = returnDefault;\n    getter.fromGraph = returnDefault;\n    getter.fromEntry = returnDefault;\n  }\n\n  return getter;\n}\n\nfunction createEdgeValueGetter(nameOrFunction, defaultValue) {\n  var getter = {};\n\n  var coerceToDefault = function (v) {\n    if (typeof v === 'undefined') return defaultValue;\n\n    return v;\n  };\n\n  if (typeof defaultValue === 'function') coerceToDefault = defaultValue;\n\n  var get = function (attributes) {\n    return coerceToDefault(attributes[nameOrFunction]);\n  };\n\n  var returnDefault = function () {\n    return coerceToDefault(undefined);\n  };\n\n  if (typeof nameOrFunction === 'string') {\n    getter.fromAttributes = get;\n    getter.fromGraph = function (graph, edge) {\n      return get(graph.getEdgeAttributes(edge));\n    };\n    getter.fromEntry = function (edge, attributes) {\n      return get(attributes);\n    };\n    getter.fromPartialEntry = getter.fromEntry;\n    getter.fromMinimalEntry = getter.fromEntry;\n  } else if (typeof nameOrFunction === 'function') {\n    getter.fromAttributes = function () {\n      throw new Error(\n        'graphology-utils/getters/createEdgeValueGetter: irrelevant usage.'\n      );\n    };\n    getter.fromGraph = function (graph, edge) {\n      // TODO: we can do better, check #310\n      var extremities = graph.extremities(edge);\n      return coerceToDefault(\n        nameOrFunction(\n          edge,\n          graph.getEdgeAttributes(edge),\n          extremities[0],\n          extremities[1],\n          graph.getNodeAttributes(extremities[0]),\n          graph.getNodeAttributes(extremities[1]),\n          graph.isUndirected(edge)\n        )\n      );\n    };\n    getter.fromEntry = function (e, a, s, t, sa, ta, u) {\n      return coerceToDefault(nameOrFunction(e, a, s, t, sa, ta, u));\n    };\n    getter.fromPartialEntry = function (e, a, s, t) {\n      return coerceToDefault(nameOrFunction(e, a, s, t));\n    };\n    getter.fromMinimalEntry = function (e, a) {\n      return coerceToDefault(nameOrFunction(e, a));\n    };\n  } else {\n    getter.fromAttributes = returnDefault;\n    getter.fromGraph = returnDefault;\n    getter.fromEntry = returnDefault;\n    getter.fromMinimalEntry = returnDefault;\n  }\n\n  return getter;\n}\n\nexports.createNodeValueGetter = createNodeValueGetter;\nexports.createEdgeValueGetter = createEdgeValueGetter;\nexports.createEdgeWeightGetter = function (name) {\n  return createEdgeValueGetter(name, coerceWeight);\n};\n", "/**\n * Mnemonist Heap Comparators\n * ===========================\n *\n * Default comparators & functions dealing with comparators reversing etc.\n */\nvar DEFAULT_COMPARATOR = function(a, b) {\n  if (a < b)\n    return -1;\n  if (a > b)\n    return 1;\n\n  return 0;\n};\n\nvar DEFAULT_REVERSE_COMPARATOR = function(a, b) {\n  if (a < b)\n    return 1;\n  if (a > b)\n    return -1;\n\n  return 0;\n};\n\n/**\n * Function used to reverse a comparator.\n */\nfunction reverseComparator(comparator) {\n  return function(a, b) {\n    return comparator(b, a);\n  };\n}\n\n/**\n * Function returning a tuple comparator.\n */\nfunction createTupleComparator(size) {\n  if (size === 2) {\n    return function(a, b) {\n      if (a[0] < b[0])\n        return -1;\n\n      if (a[0] > b[0])\n        return 1;\n\n      if (a[1] < b[1])\n        return -1;\n\n      if (a[1] > b[1])\n        return 1;\n\n      return 0;\n    };\n  }\n\n  return function(a, b) {\n    var i = 0;\n\n    while (i < size) {\n      if (a[i] < b[i])\n        return -1;\n\n      if (a[i] > b[i])\n        return 1;\n\n      i++;\n    }\n\n    return 0;\n  };\n}\n\n/**\n * Exporting.\n */\nexports.DEFAULT_COMPARATOR = DEFAULT_COMPARATOR;\nexports.DEFAULT_REVERSE_COMPARATOR = DEFAULT_REVERSE_COMPARATOR;\nexports.reverseComparator = reverseComparator;\nexports.createTupleComparator = createTupleComparator;\n", "/**\n * Mnemonist Typed Array Helpers\n * ==============================\n *\n * Miscellaneous helpers related to typed arrays.\n */\n\n/**\n * When using an unsigned integer array to store pointers, one might want to\n * choose the optimal word size in regards to the actual numbers of pointers\n * to store.\n *\n * This helpers does just that.\n *\n * @param  {number} size - Expected size of the array to map.\n * @return {TypedArray}\n */\nvar MAX_8BIT_INTEGER = Math.pow(2, 8) - 1,\n    MAX_16BIT_INTEGER = Math.pow(2, 16) - 1,\n    MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;\n\nvar MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1,\n    MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1,\n    MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;\n\nexports.getPointerArray = function(size) {\n  var maxIndex = size - 1;\n\n  if (maxIndex <= MAX_8BIT_INTEGER)\n    return Uint8Array;\n\n  if (maxIndex <= MAX_16BIT_INTEGER)\n    return Uint16Array;\n\n  if (maxIndex <= MAX_32BIT_INTEGER)\n    return Uint32Array;\n\n  throw new Error('mnemonist: Pointer Array of size > 4294967295 is not supported.');\n};\n\nexports.getSignedPointerArray = function(size) {\n  var maxIndex = size - 1;\n\n  if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)\n    return Int8Array;\n\n  if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)\n    return Int16Array;\n\n  if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)\n    return Int32Array;\n\n  return Float64Array;\n};\n\n/**\n * Function returning the minimal type able to represent the given number.\n *\n * @param  {number} value - Value to test.\n * @return {TypedArrayClass}\n */\nexports.getNumberType = function(value) {\n\n  // <= 32 bits itnteger?\n  if (value === (value | 0)) {\n\n    // Negative\n    if (Math.sign(value) === -1) {\n      if (value <= 127 && value >= -128)\n        return Int8Array;\n\n      if (value <= 32767 && value >= -32768)\n        return Int16Array;\n\n      return Int32Array;\n    }\n    else {\n\n      if (value <= 255)\n        return Uint8Array;\n\n      if (value <= 65535)\n        return Uint16Array;\n\n      return Uint32Array;\n    }\n  }\n\n  // 53 bits integer & floats\n  // NOTE: it's kinda hard to tell whether we could use 32bits or not...\n  return Float64Array;\n};\n\n/**\n * Function returning the minimal type able to represent the given array\n * of JavaScript numbers.\n *\n * @param  {array}    array  - Array to represent.\n * @param  {function} getter - Optional getter.\n * @return {TypedArrayClass}\n */\nvar TYPE_PRIORITY = {\n  Uint8Array: 1,\n  Int8Array: 2,\n  Uint16Array: 3,\n  Int16Array: 4,\n  Uint32Array: 5,\n  Int32Array: 6,\n  Float32Array: 7,\n  Float64Array: 8\n};\n\n// TODO: make this a one-shot for one value\nexports.getMinimalRepresentation = function(array, getter) {\n  var maxType = null,\n      maxPriority = 0,\n      p,\n      t,\n      v,\n      i,\n      l;\n\n  for (i = 0, l = array.length; i < l; i++) {\n    v = getter ? getter(array[i]) : array[i];\n    t = exports.getNumberType(v);\n    p = TYPE_PRIORITY[t.name];\n\n    if (p > maxPriority) {\n      maxPriority = p;\n      maxType = t;\n    }\n  }\n\n  return maxType;\n};\n\n/**\n * Function returning whether the given value is a typed array.\n *\n * @param  {any} value - Value to test.\n * @return {boolean}\n */\nexports.isTypedArray = function(value) {\n  return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(value);\n};\n\n/**\n * Function used to concat byte arrays.\n *\n * @param  {...ByteArray}\n * @return {ByteArray}\n */\nexports.concat = function() {\n  var length = 0,\n      i,\n      o,\n      l;\n\n  for (i = 0, l = arguments.length; i < l; i++)\n    length += arguments[i].length;\n\n  var array = new (arguments[0].constructor)(length);\n\n  for (i = 0, o = 0; i < l; i++) {\n    array.set(arguments[i], o);\n    o += arguments[i].length;\n  }\n\n  return array;\n};\n\n/**\n * Function used to initialize a byte array of indices.\n *\n * @param  {number}    length - Length of target.\n * @return {ByteArray}\n */\nexports.indices = function(length) {\n  var PointerArray = exports.getPointerArray(length);\n\n  var array = new PointerArray(length);\n\n  for (var i = 0; i < length; i++)\n    array[i] = i;\n\n  return array;\n};\n", "/**\n * Mnemonist Iterable Function\n * ============================\n *\n * Harmonized iteration helpers over mixed iterable targets.\n */\nvar forEach = require('obliterator/foreach');\n\nvar typed = require('./typed-arrays.js');\n\n/**\n * Function used to determine whether the given object supports array-like\n * random access.\n *\n * @param  {any} target - Target object.\n * @return {boolean}\n */\nfunction isArrayLike(target) {\n  return Array.isArray(target) || typed.isTypedArray(target);\n}\n\n/**\n * Function used to guess the length of the structure over which we are going\n * to iterate.\n *\n * @param  {any} target - Target object.\n * @return {number|undefined}\n */\nfunction guessLength(target) {\n  if (typeof target.length === 'number')\n    return target.length;\n\n  if (typeof target.size === 'number')\n    return target.size;\n\n  return;\n}\n\n/**\n * Function used to convert an iterable to an array.\n *\n * @param  {any}   target - Iteration target.\n * @return {array}\n */\nfunction toArray(target) {\n  var l = guessLength(target);\n\n  var array = typeof l === 'number' ? new Array(l) : [];\n\n  var i = 0;\n\n  // TODO: we could optimize when given target is array like\n  forEach(target, function(value) {\n    array[i++] = value;\n  });\n\n  return array;\n}\n\n/**\n * Same as above but returns a supplementary indices array.\n *\n * @param  {any}   target - Iteration target.\n * @return {array}\n */\nfunction toArrayWithIndices(target) {\n  var l = guessLength(target);\n\n  var IndexArray = typeof l === 'number' ?\n    typed.getPointerArray(l) :\n    Array;\n\n  var array = typeof l === 'number' ? new Array(l) : [];\n  var indices = typeof l === 'number' ? new IndexArray(l) : [];\n\n  var i = 0;\n\n  // TODO: we could optimize when given target is array like\n  forEach(target, function(value) {\n    array[i] = value;\n    indices[i] = i++;\n  });\n\n  return [array, indices];\n}\n\n/**\n * Exporting.\n */\nexports.isArrayLike = isArrayLike;\nexports.guessLength = guessLength;\nexports.toArray = toArray;\nexports.toArrayWithIndices = toArrayWithIndices;\n", "/**\n * Mnemonist Binary Heap\n * ======================\n *\n * Binary heap implementation.\n */\nvar forEach = require('obliterator/foreach'),\n    comparators = require('./utils/comparators.js'),\n    iterables = require('./utils/iterables.js');\n\nvar DEFAULT_COMPARATOR = comparators.DEFAULT_COMPARATOR,\n    reverseComparator = comparators.reverseComparator;\n\n/**\n * Heap helper functions.\n */\n\n/**\n * Function used to sift down.\n *\n * @param {function} compare    - Comparison function.\n * @param {array}    heap       - Array storing the heap's data.\n * @param {number}   startIndex - Starting index.\n * @param {number}   i          - Index.\n */\nfunction siftDown(compare, heap, startIndex, i) {\n  var item = heap[i],\n      parentIndex,\n      parent;\n\n  while (i > startIndex) {\n    parentIndex = (i - 1) >> 1;\n    parent = heap[parentIndex];\n\n    if (compare(item, parent) < 0) {\n      heap[i] = parent;\n      i = parentIndex;\n      continue;\n    }\n\n    break;\n  }\n\n  heap[i] = item;\n}\n\n/**\n * Function used to sift up.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    heap    - Array storing the heap's data.\n * @param {number}   i       - Index.\n */\nfunction siftUp(compare, heap, i) {\n  var endIndex = heap.length,\n      startIndex = i,\n      item = heap[i],\n      childIndex = 2 * i + 1,\n      rightIndex;\n\n  while (childIndex < endIndex) {\n    rightIndex = childIndex + 1;\n\n    if (\n      rightIndex < endIndex &&\n      compare(heap[childIndex], heap[rightIndex]) >= 0\n    ) {\n      childIndex = rightIndex;\n    }\n\n    heap[i] = heap[childIndex];\n    i = childIndex;\n    childIndex = 2 * i + 1;\n  }\n\n  heap[i] = item;\n  siftDown(compare, heap, startIndex, i);\n}\n\n/**\n * Function used to push an item into a heap represented by a raw array.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    heap    - Array storing the heap's data.\n * @param {any}      item    - Item to push.\n */\nfunction push(compare, heap, item) {\n  heap.push(item);\n  siftDown(compare, heap, 0, heap.length - 1);\n}\n\n/**\n * Function used to pop an item from a heap represented by a raw array.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @return {any}\n */\nfunction pop(compare, heap) {\n  var lastItem = heap.pop();\n\n  if (heap.length !== 0) {\n    var item = heap[0];\n    heap[0] = lastItem;\n    siftUp(compare, heap, 0);\n\n    return item;\n  }\n\n  return lastItem;\n}\n\n/**\n * Function used to pop the heap then push a new value into it, thus \"replacing\"\n * it.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @param  {any}      item    - The item to push.\n * @return {any}\n */\nfunction replace(compare, heap, item) {\n  if (heap.length === 0)\n    throw new Error('mnemonist/heap.replace: cannot pop an empty heap.');\n\n  var popped = heap[0];\n  heap[0] = item;\n  siftUp(compare, heap, 0);\n\n  return popped;\n}\n\n/**\n * Function used to push an item in the heap then pop the heap and return the\n * popped value.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @param  {any}      item    - The item to push.\n * @return {any}\n */\nfunction pushpop(compare, heap, item) {\n  var tmp;\n\n  if (heap.length !== 0 && compare(heap[0], item) < 0) {\n    tmp = heap[0];\n    heap[0] = item;\n    item = tmp;\n    siftUp(compare, heap, 0);\n  }\n\n  return item;\n}\n\n/**\n * Converts and array into an abstract heap in linear time.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    array   - Target array.\n */\nfunction heapify(compare, array) {\n  var n = array.length,\n      l = n >> 1,\n      i = l;\n\n  while (--i >= 0)\n    siftUp(compare, array, i);\n}\n\n/**\n * Fully consumes the given heap.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @return {array}\n */\nfunction consume(compare, heap) {\n  var l = heap.length,\n      i = 0;\n\n  var array = new Array(l);\n\n  while (i < l)\n    array[i++] = pop(compare, heap);\n\n  return array;\n}\n\n/**\n * Function used to retrieve the n smallest items from the given iterable.\n *\n * @param {function} compare  - Comparison function.\n * @param {number}   n        - Number of top items to retrieve.\n * @param {any}      iterable - Arbitrary iterable.\n * @param {array}\n */\nfunction nsmallest(compare, n, iterable) {\n  if (arguments.length === 2) {\n    iterable = n;\n    n = compare;\n    compare = DEFAULT_COMPARATOR;\n  }\n\n  var reverseCompare = reverseComparator(compare);\n\n  var i, l, v;\n\n  var min = Infinity;\n\n  var result;\n\n  // If n is equal to 1, it's just a matter of finding the minimum\n  if (n === 1) {\n    if (iterables.isArrayLike(iterable)) {\n      for (i = 0, l = iterable.length; i < l; i++) {\n        v = iterable[i];\n\n        if (min === Infinity || compare(v, min) < 0)\n          min = v;\n      }\n\n      result = new iterable.constructor(1);\n      result[0] = min;\n\n      return result;\n    }\n\n    forEach(iterable, function(value) {\n      if (min === Infinity || compare(value, min) < 0)\n        min = value;\n    });\n\n    return [min];\n  }\n\n  if (iterables.isArrayLike(iterable)) {\n\n    // If n > iterable length, we just clone and sort\n    if (n >= iterable.length)\n      return iterable.slice().sort(compare);\n\n    result = iterable.slice(0, n);\n    heapify(reverseCompare, result);\n\n    for (i = n, l = iterable.length; i < l; i++)\n      if (reverseCompare(iterable[i], result[0]) > 0)\n        replace(reverseCompare, result, iterable[i]);\n\n    // NOTE: if n is over some number, it becomes faster to consume the heap\n    return result.sort(compare);\n  }\n\n  // Correct for size\n  var size = iterables.guessLength(iterable);\n\n  if (size !== null && size < n)\n    n = size;\n\n  result = new Array(n);\n  i = 0;\n\n  forEach(iterable, function(value) {\n    if (i < n) {\n      result[i] = value;\n    }\n    else {\n      if (i === n)\n        heapify(reverseCompare, result);\n\n      if (reverseCompare(value, result[0]) > 0)\n        replace(reverseCompare, result, value);\n    }\n\n    i++;\n  });\n\n  if (result.length > i)\n    result.length = i;\n\n  // NOTE: if n is over some number, it becomes faster to consume the heap\n  return result.sort(compare);\n}\n\n/**\n * Function used to retrieve the n largest items from the given iterable.\n *\n * @param {function} compare  - Comparison function.\n * @param {number}   n        - Number of top items to retrieve.\n * @param {any}      iterable - Arbitrary iterable.\n * @param {array}\n */\nfunction nlargest(compare, n, iterable) {\n  if (arguments.length === 2) {\n    iterable = n;\n    n = compare;\n    compare = DEFAULT_COMPARATOR;\n  }\n\n  var reverseCompare = reverseComparator(compare);\n\n  var i, l, v;\n\n  var max = -Infinity;\n\n  var result;\n\n  // If n is equal to 1, it's just a matter of finding the maximum\n  if (n === 1) {\n    if (iterables.isArrayLike(iterable)) {\n      for (i = 0, l = iterable.length; i < l; i++) {\n        v = iterable[i];\n\n        if (max === -Infinity || compare(v, max) > 0)\n          max = v;\n      }\n\n      result = new iterable.constructor(1);\n      result[0] = max;\n\n      return result;\n    }\n\n    forEach(iterable, function(value) {\n      if (max === -Infinity || compare(value, max) > 0)\n        max = value;\n    });\n\n    return [max];\n  }\n\n  if (iterables.isArrayLike(iterable)) {\n\n    // If n > iterable length, we just clone and sort\n    if (n >= iterable.length)\n      return iterable.slice().sort(reverseCompare);\n\n    result = iterable.slice(0, n);\n    heapify(compare, result);\n\n    for (i = n, l = iterable.length; i < l; i++)\n      if (compare(iterable[i], result[0]) > 0)\n        replace(compare, result, iterable[i]);\n\n    // NOTE: if n is over some number, it becomes faster to consume the heap\n    return result.sort(reverseCompare);\n  }\n\n  // Correct for size\n  var size = iterables.guessLength(iterable);\n\n  if (size !== null && size < n)\n    n = size;\n\n  result = new Array(n);\n  i = 0;\n\n  forEach(iterable, function(value) {\n    if (i < n) {\n      result[i] = value;\n    }\n    else {\n      if (i === n)\n        heapify(compare, result);\n\n      if (compare(value, result[0]) > 0)\n        replace(compare, result, value);\n    }\n\n    i++;\n  });\n\n  if (result.length > i)\n    result.length = i;\n\n  // NOTE: if n is over some number, it becomes faster to consume the heap\n  return result.sort(reverseCompare);\n}\n\n/**\n * Binary Minimum Heap.\n *\n * @constructor\n * @param {function} comparator - Comparator function to use.\n */\nfunction Heap(comparator) {\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n\n  if (typeof this.comparator !== 'function')\n    throw new Error('mnemonist/Heap.constructor: given comparator should be a function.');\n}\n\n/**\n * Method used to clear the heap.\n *\n * @return {undefined}\n */\nHeap.prototype.clear = function() {\n\n  // Properties\n  this.items = [];\n  this.size = 0;\n};\n\n/**\n * Method used to push an item into the heap.\n *\n * @param  {any}    item - Item to push.\n * @return {number}\n */\nHeap.prototype.push = function(item) {\n  push(this.comparator, this.items, item);\n  return ++this.size;\n};\n\n/**\n * Method used to retrieve the \"first\" item of the heap.\n *\n * @return {any}\n */\nHeap.prototype.peek = function() {\n  return this.items[0];\n};\n\n/**\n * Method used to retrieve & remove the \"first\" item of the heap.\n *\n * @return {any}\n */\nHeap.prototype.pop = function() {\n  if (this.size !== 0)\n    this.size--;\n\n  return pop(this.comparator, this.items);\n};\n\n/**\n * Method used to pop the heap, then push an item and return the popped\n * item.\n *\n * @param  {any} item - Item to push into the heap.\n * @return {any}\n */\nHeap.prototype.replace = function(item) {\n  return replace(this.comparator, this.items, item);\n};\n\n/**\n * Method used to push the heap, the pop it and return the pooped item.\n *\n * @param  {any} item - Item to push into the heap.\n * @return {any}\n */\nHeap.prototype.pushpop = function(item) {\n  return pushpop(this.comparator, this.items, item);\n};\n\n/**\n * Method used to consume the heap fully and return its items as a sorted array.\n *\n * @return {array}\n */\nHeap.prototype.consume = function() {\n  this.size = 0;\n  return consume(this.comparator, this.items);\n};\n\n/**\n * Method used to convert the heap to an array. Note that it basically clone\n * the heap and consumes it completely. This is hardly performant.\n *\n * @return {array}\n */\nHeap.prototype.toArray = function() {\n  return consume(this.comparator, this.items.slice());\n};\n\n/**\n * Convenience known methods.\n */\nHeap.prototype.inspect = function() {\n  var proxy = this.toArray();\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: Heap,\n    enumerable: false\n  });\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  Heap.prototype[Symbol.for('nodejs.util.inspect.custom')] = Heap.prototype.inspect;\n\n/**\n * Binary Maximum Heap.\n *\n * @constructor\n * @param {function} comparator - Comparator function to use.\n */\nfunction MaxHeap(comparator) {\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n\n  if (typeof this.comparator !== 'function')\n    throw new Error('mnemonist/MaxHeap.constructor: given comparator should be a function.');\n\n  this.comparator = reverseComparator(this.comparator);\n}\n\nMaxHeap.prototype = Heap.prototype;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a heap.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {function} comparator - Custom comparator function.\n * @return {Heap}\n */\nHeap.from = function(iterable, comparator) {\n  var heap = new Heap(comparator);\n\n  var items;\n\n  // If iterable is an array, we can be clever about it\n  if (iterables.isArrayLike(iterable))\n    items = iterable.slice();\n  else\n    items = iterables.toArray(iterable);\n\n  heapify(heap.comparator, items);\n  heap.items = items;\n  heap.size = items.length;\n\n  return heap;\n};\n\nMaxHeap.from = function(iterable, comparator) {\n  var heap = new MaxHeap(comparator);\n\n  var items;\n\n  // If iterable is an array, we can be clever about it\n  if (iterables.isArrayLike(iterable))\n    items = iterable.slice();\n  else\n    items = iterables.toArray(iterable);\n\n  heapify(heap.comparator, items);\n  heap.items = items;\n  heap.size = items.length;\n\n  return heap;\n};\n\n/**\n * Exporting.\n */\nHeap.siftUp = siftUp;\nHeap.siftDown = siftDown;\nHeap.push = push;\nHeap.pop = pop;\nHeap.replace = replace;\nHeap.pushpop = pushpop;\nHeap.heapify = heapify;\nHeap.consume = consume;\n\nHeap.nsmallest = nsmallest;\nHeap.nlargest = nlargest;\n\nHeap.MinHeap = Heap;\nHeap.MaxHeap = MaxHeap;\n\nmodule.exports = Heap;\n", "/**\n * Graphology Dijkstra Shortest Path\n * ==================================\n *\n * Graphology implementation of Dijkstra shortest path for weighted graphs.\n */\nvar isGraph = require('graphology-utils/is-graph');\nvar createEdgeWeightGetter =\n  require('graphology-utils/getters').createEdgeWeightGetter;\nvar Heap = require('mnemonist/heap');\n\n/**\n * Defaults & helpers.\n */\nvar DEFAULT_WEIGHT_ATTRIBUTE = 'weight';\n\nfunction DIJKSTRA_HEAP_COMPARATOR(a, b) {\n  if (a[0] > b[0]) return 1;\n  if (a[0] < b[0]) return -1;\n\n  if (a[1] > b[1]) return 1;\n  if (a[1] < b[1]) return -1;\n\n  if (a[2] > b[2]) return 1;\n  if (a[2] < b[2]) return -1;\n\n  return 0;\n}\n\nfunction BRANDES_DIJKSTRA_HEAP_COMPARATOR(a, b) {\n  if (a[0] > b[0]) return 1;\n  if (a[0] < b[0]) return -1;\n\n  if (a[1] > b[1]) return 1;\n  if (a[1] < b[1]) return -1;\n\n  if (a[2] > b[2]) return 1;\n  if (a[2] < b[2]) return -1;\n\n  if (a[3] > b[3]) return 1;\n  if (a[3] < b[3]) return -1;\n\n  return 0;\n}\n\n/**\n * Bidirectional Dijkstra shortest path between source & target node abstract.\n *\n * Note that this implementation was basically copied from networkx.\n *\n * @param  {Graph}  graph         - The graphology instance.\n * @param  {string} source        - Source node.\n * @param  {string} target        - Target node.\n * @param  {string} getEdgeWeight - Name of the weight attribute or getter function.\n * @param  {array}                - The found path if any and its cost.\n */\nfunction abstractBidirectionalDijkstra(graph, source, target, getEdgeWeight) {\n  source = '' + source;\n  target = '' + target;\n\n  // Sanity checks\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-shortest-path/dijkstra: invalid graphology instance.'\n    );\n\n  if (source && !graph.hasNode(source))\n    throw new Error(\n      'graphology-shortest-path/dijkstra: the \"' +\n        source +\n        '\" source node does not exist in the given graph.'\n    );\n\n  if (target && !graph.hasNode(target))\n    throw new Error(\n      'graphology-shortest-path/dijkstra: the \"' +\n        target +\n        '\" target node does not exist in the given graph.'\n    );\n\n  getEdgeWeight = createEdgeWeightGetter(\n    getEdgeWeight || DEFAULT_WEIGHT_ATTRIBUTE\n  ).fromMinimalEntry;\n\n  if (source === target) return [0, [source]];\n\n  var distances = [{}, {}],\n    paths = [{}, {}],\n    fringe = [\n      new Heap(DIJKSTRA_HEAP_COMPARATOR),\n      new Heap(DIJKSTRA_HEAP_COMPARATOR)\n    ],\n    seen = [{}, {}];\n\n  paths[0][source] = [source];\n  paths[1][target] = [target];\n\n  seen[0][source] = 0;\n  seen[1][target] = 0;\n\n  var finalPath = [],\n    finalDistance = Infinity;\n\n  var count = 0,\n    dir = 1,\n    item,\n    edges,\n    cost,\n    d,\n    v,\n    u,\n    e,\n    i,\n    l;\n\n  fringe[0].push([0, count++, source]);\n  fringe[1].push([0, count++, target]);\n\n  while (fringe[0].size && fringe[1].size) {\n    // Swapping direction\n    dir = 1 - dir;\n\n    item = fringe[dir].pop();\n    d = item[0];\n    v = item[2];\n\n    if (v in distances[dir]) continue;\n\n    distances[dir][v] = d;\n\n    // Shortest path is found?\n    if (v in distances[1 - dir]) return [finalDistance, finalPath];\n\n    edges = dir === 1 ? graph.inboundEdges(v) : graph.outboundEdges(v);\n\n    for (i = 0, l = edges.length; i < l; i++) {\n      e = edges[i];\n      u = graph.opposite(v, e);\n      cost = distances[dir][v] + getEdgeWeight(e, graph.getEdgeAttributes(e));\n\n      if (u in distances[dir] && cost < distances[dir][u]) {\n        throw Error(\n          'graphology-shortest-path/dijkstra: contradictory paths found. Do some of your edges have a negative weight?'\n        );\n      } else if (!(u in seen[dir]) || cost < seen[dir][u]) {\n        seen[dir][u] = cost;\n        fringe[dir].push([cost, count++, u]);\n        paths[dir][u] = paths[dir][v].concat(u);\n\n        if (u in seen[0] && u in seen[1]) {\n          d = seen[0][u] + seen[1][u];\n\n          if (finalPath.length === 0 || finalDistance > d) {\n            finalDistance = d;\n            finalPath = paths[0][u].concat(paths[1][u].slice(0, -1).reverse());\n          }\n        }\n      }\n    }\n  }\n\n  // No path was found\n  return [Infinity, null];\n}\n\n/**\n * Multisource Dijkstra shortest path abstract function. This function is the\n * basis of the algorithm that every other will use.\n *\n * Note that this implementation was basically copied from networkx.\n * TODO: it might be more performant to use a dedicated objet for the heap's\n * items.\n *\n * @param  {Graph}  graph         - The graphology instance.\n * @param  {array}  sources       - A list of sources.\n * @param  {string} getEdgeWeight - Name of the weight attribute or getter function.\n * @param  {number} cutoff        - Maximum depth of the search.\n * @param  {string} target        - Optional target to reach.\n * @param  {object} paths         - Optional paths object to maintain.\n * @return {object}               - Returns the paths.\n */\nfunction abstractDijkstraMultisource(\n  graph,\n  sources,\n  getEdgeWeight,\n  cutoff,\n  target,\n  paths\n) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-shortest-path/dijkstra: invalid graphology instance.'\n    );\n\n  if (target && !graph.hasNode(target))\n    throw new Error(\n      'graphology-shortest-path/dijkstra: the \"' +\n        target +\n        '\" target node does not exist in the given graph.'\n    );\n\n  getEdgeWeight = createEdgeWeightGetter(\n    getEdgeWeight || DEFAULT_WEIGHT_ATTRIBUTE\n  ).fromMinimalEntry;\n\n  var distances = {},\n    seen = {},\n    fringe = new Heap(DIJKSTRA_HEAP_COMPARATOR);\n\n  var count = 0,\n    edges,\n    item,\n    cost,\n    v,\n    u,\n    e,\n    d,\n    i,\n    j,\n    l,\n    m;\n\n  for (i = 0, l = sources.length; i < l; i++) {\n    v = sources[i];\n    seen[v] = 0;\n    fringe.push([0, count++, v]);\n\n    if (paths) paths[v] = [v];\n  }\n\n  while (fringe.size) {\n    item = fringe.pop();\n    d = item[0];\n    v = item[2];\n\n    if (v in distances) continue;\n\n    distances[v] = d;\n\n    if (v === target) break;\n\n    edges = graph.outboundEdges(v);\n\n    for (j = 0, m = edges.length; j < m; j++) {\n      e = edges[j];\n      u = graph.opposite(v, e);\n      cost = getEdgeWeight(e, graph.getEdgeAttributes(e)) + distances[v];\n\n      if (cutoff && cost > cutoff) continue;\n\n      if (u in distances && cost < distances[u]) {\n        throw Error(\n          'graphology-shortest-path/dijkstra: contradictory paths found. Do some of your edges have a negative weight?'\n        );\n      } else if (!(u in seen) || cost < seen[u]) {\n        seen[u] = cost;\n        fringe.push([cost, count++, u]);\n\n        if (paths) paths[u] = paths[v].concat(u);\n      }\n    }\n  }\n\n  return distances;\n}\n\n/**\n * Single source Dijkstra shortest path between given node & other nodes in\n * the graph.\n *\n * @param  {Graph}  graph         - The graphology instance.\n * @param  {string} source        - Source node.\n * @param  {string} getEdgeWeight - Name of the weight attribute or getter function.\n * @return {object}               - An object of found paths.\n */\nfunction singleSourceDijkstra(graph, source, getEdgeWeight) {\n  var paths = {};\n\n  abstractDijkstraMultisource(graph, [source], getEdgeWeight, 0, null, paths);\n\n  return paths;\n}\n\nfunction bidirectionalDijkstra(graph, source, target, getEdgeWeight) {\n  return abstractBidirectionalDijkstra(graph, source, target, getEdgeWeight)[1];\n}\n\n/**\n * Function using Ulrik Brandes' method to map single source shortest paths\n * from selected node.\n *\n * [Reference]:\n * Ulrik Brandes: A Faster Algorithm for Betweenness Centrality.\n * Journal of Mathematical Sociology 25(2):163-177, 2001.\n *\n * @param  {Graph}  graph         - Target graph.\n * @param  {any}    source        - Source node.\n * @param  {string} getEdgeWeight - Name of the weight attribute or getter function.\n * @return {array}                - [Stack, Paths, Sigma]\n */\nfunction brandes(graph, source, getEdgeWeight) {\n  source = '' + source;\n\n  getEdgeWeight = createEdgeWeightGetter(\n    getEdgeWeight || DEFAULT_WEIGHT_ATTRIBUTE\n  ).fromMinimalEntry;\n\n  var S = [],\n    P = {},\n    sigma = {};\n\n  var nodes = graph.nodes(),\n    edges,\n    item,\n    pred,\n    dist,\n    cost,\n    v,\n    w,\n    e,\n    i,\n    l;\n\n  for (i = 0, l = nodes.length; i < l; i++) {\n    v = nodes[i];\n    P[v] = [];\n    sigma[v] = 0;\n  }\n\n  var D = {};\n\n  sigma[source] = 1;\n\n  var seen = {};\n  seen[source] = 0;\n\n  var count = 0;\n\n  var Q = new Heap(BRANDES_DIJKSTRA_HEAP_COMPARATOR);\n  Q.push([0, count++, source, source]);\n\n  while (Q.size) {\n    item = Q.pop();\n    dist = item[0];\n    pred = item[2];\n    v = item[3];\n\n    if (v in D) continue;\n\n    sigma[v] += sigma[pred];\n    S.push(v);\n    D[v] = dist;\n\n    edges = graph.outboundEdges(v);\n\n    for (i = 0, l = edges.length; i < l; i++) {\n      e = edges[i];\n      w = graph.opposite(v, e);\n      cost = dist + getEdgeWeight(e, graph.getEdgeAttributes(e));\n\n      if (!(w in D) && (!(w in seen) || cost < seen[w])) {\n        seen[w] = cost;\n        Q.push([cost, count++, v, w]);\n        sigma[w] = 0;\n        P[w] = [v];\n      } else if (cost === seen[w]) {\n        sigma[w] += sigma[v];\n        P[w].push(v);\n      }\n    }\n  }\n\n  return [S, P, sigma];\n}\n\n/**\n * Exporting.\n */\nexports.bidirectional = bidirectionalDijkstra;\nexports.singleSource = singleSourceDijkstra;\nexports.brandes = brandes;\n", "/**\n * Graphology Shortest Path\n * =========================\n *\n * Library endpoint.\n */\nvar unweighted = require('./unweighted.js');\nvar utils = require('./utils.js');\n\nexports.unweighted = unweighted;\nexports.dijkstra = require('./dijkstra.js');\n\nexports.bidirectional = unweighted.bidirectional;\nexports.singleSource = unweighted.singleSource;\nexports.singleSourceLength = unweighted.singleSourceLength;\nexports.undirectedSingleSourceLength = unweighted.undirectedSingleSourceLength;\nexports.brandes = unweighted.brandes;\n\nexports.edgePathFromNodePath = utils.edgePathFromNodePath;\n"],
  "mappings": "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",
  "names": []
}
