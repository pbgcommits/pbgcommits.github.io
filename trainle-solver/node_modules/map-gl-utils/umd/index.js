(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.U = factory());
}(this, (function () { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = o[Symbol.iterator]();
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var allProps = {
    paints: 'fill-antialias,fill-opacity,fill-color,fill-outline-color,fill-translate,fill-translate-anchor,fill-pattern,fill-extrusion-opacity,fill-extrusion-color,fill-extrusion-translate,fill-extrusion-translate-anchor,fill-extrusion-pattern,fill-extrusion-height,fill-extrusion-base,fill-extrusion-vertical-gradient,line-opacity,line-color,line-translate,line-translate-anchor,line-width,line-gap-width,line-offset,line-blur,line-dasharray,line-pattern,line-gradient,circle-radius,circle-color,circle-blur,circle-opacity,circle-translate,circle-translate-anchor,circle-pitch-scale,circle-pitch-alignment,circle-stroke-width,circle-stroke-color,circle-stroke-opacity,heatmap-radius,heatmap-weight,heatmap-intensity,heatmap-color,heatmap-opacity,icon-opacity,icon-color,icon-halo-color,icon-halo-width,icon-halo-blur,icon-translate,icon-translate-anchor,text-opacity,text-color,text-halo-color,text-halo-width,text-halo-blur,text-translate,text-translate-anchor,raster-opacity,raster-hue-rotate,raster-brightness-min,raster-brightness-max,raster-saturation,raster-contrast,raster-resampling,raster-fade-duration,hillshade-illumination-direction,hillshade-illumination-anchor,hillshade-exaggeration,hillshade-shadow-color,hillshade-highlight-color,hillshade-accent-color,background-color,background-pattern,background-opacity,sky-type,sky-atmosphere-sun,sky-atmosphere-sun-intensity,sky-gradient-center,sky-gradient-radius,sky-gradient,sky-atmosphere-halo-color,sky-atmosphere-color,sky-opacity'.split(','),
    layouts: 'visibility,fill-sort-key,circle-sort-key,line-cap,line-join,line-miter-limit,line-round-limit,line-sort-key,symbol-placement,symbol-spacing,symbol-avoid-edges,symbol-sort-key,symbol-z-order,icon-allow-overlap,icon-ignore-placement,icon-optional,icon-rotation-alignment,icon-size,icon-text-fit,icon-text-fit-padding,icon-image,icon-rotate,icon-padding,icon-keep-upright,icon-offset,icon-anchor,icon-pitch-alignment,text-pitch-alignment,text-rotation-alignment,text-field,text-font,text-size,text-max-width,text-line-height,text-letter-spacing,text-justify,text-radial-offset,text-variable-anchor,text-anchor,text-max-angle,text-writing-mode,text-rotate,text-padding,text-keep-upright,text-transform,text-offset,text-allow-overlap,text-ignore-placement,text-optional'.split(',')
  };

  // not currently used - weird, makeSource is really returning something slightly different from normal MapGlUtils
  // export type UtilsSource = {
  //     map: UtilsMap,
  //     mapboxgl: Class<MapboxGl>,
  //     // todo add the layer type functions
  // };

  var kebabCase = function kebabCase(s) {
    return s.replace(/[A-Z]/g, function (m) {
      return "-".concat(m.toLowerCase());
    });
  };

  var upperCamelCase = function upperCamelCase(s) {
    return s.replace(/(^|-)([a-z])/g, function (x, y, l) {
      return "".concat(l.toUpperCase());
    });
  };

  function isPaintProp(prop) {
    return allProps.paints.indexOf(prop) >= 0;
  }

  function isLayoutProp(prop) {
    return allProps.layouts.indexOf(prop) >= 0;
  }

  function whichProp(prop) {
    if (allProps.paints.indexOf(prop) >= 0) {
      return 'paint';
    }

    if (allProps.layouts.indexOf(prop) >= 0) {
      return 'layout';
    }

    return 'other';
  }

  function parseSource(source) {
    if (String(source).match(/\.(geo)?json/) || source.type === 'Feature' || source.type === 'FeatureCollection') {
      return {
        type: 'geojson',
        data: source
      };
    } else if (String(source).match(/^mapbox:\/\//)) {
      return {
        type: 'vector',
        url: source
      };
    } else {
      return source;
    }
  } // so basically any
  // turn a thing, an array of things, a regex or a filter function, into an array


  var resolveArray = function resolveArray(things, map) {
    if (Array.isArray(things)) {
      return things;
    } else if (things instanceof RegExp) {
      return map.getStyle().layers.map(function (l) {
        return l.id;
      }).filter(function (id) {
        return id.match(things);
      });
    } else if (things instanceof Function) {
      return map.getStyle().layers.filter(function (layer) {
        return things(layer);
      }).map(function (l) {
        return l.id;
      });
    } else {
      return [things];
    }
  };
  //     (LayerRef, ...args: Args) => void
  // )
  // Magically turn a function that works on one layer into one that works on multiple layers
  // specified as: an array, a regex (on layer id), or filter function (on layer definition)

  /*
  Cannot return function because in the first argument: [incompatible-return] Either function type [1] is incompatible with `RegExp` [2].
  Or `FillLayerSpecification` [3] is incompatible with `RegExp` [2] in the first argument.
  Or a call signature declaring the expected parameter / return type is missing in `FillLayerSpecification` [3] but exists in function type [4] in the first argument. (index.js:131:12)flow
  */


  var arrayify = function arrayify(f) {
    return function (thingOrThings) {
      var _this2 = this;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      var things = resolveArray(thingOrThings, this.map);
      return things.forEach(function (t) {
        return f.call.apply(f, [_this2, t].concat(args));
      });
    };
  }; // todo
  // assuming each function returns an 'off' handler, returns a function that calls them all


  var arrayifyAndOff = function arrayifyAndOff(f) {
    return function (thingOrThings) {
      var _this3 = this;

      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      var things = resolveArray(thingOrThings, this.map);
      var offs = things.map(function (t) {
        return f.call.apply(f, [_this3, t].concat(args));
      });
      return function () {
        return offs.forEach(function (off) {
          return off();
        });
      };
    };
  };

  var layerTypes = ['line', 'fill', 'circle', 'symbol', 'video', 'raster', 'fill-extrusion', 'heatmap', 'hillshade']; // $FlowFixMe[prop-missing]

  var MapGlUtils = /*#__PURE__*/function () {
    function MapGlUtils() {
      _classCallCheck(this, MapGlUtils);

      _defineProperty(this, "_loaded", false);

      _defineProperty(this, "_mapgl", null);

      _defineProperty(this, "map", null);

      _defineProperty(this, "hoverFeatureState", arrayifyAndOff(function (layer, source, sourceLayer, enterCb, leaveCb) {
        var _this4 = this;

        if (Array.isArray(source)) {
          // assume we have array of [source, sourceLayer]
          var removeFuncs = source.map(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                source = _ref2[0],
                sourceLayer = _ref2[1];

            return _this4.hoverFeatureState(layer, source, sourceLayer);
          });
          return function () {
            return removeFuncs.forEach(function (f) {
              return f();
            });
          };
        }

        if (source === undefined) {
          var l = this.getLayerStyle(layer);
          source = l.source;
          sourceLayer = l['source-layer'];
        }

        var featureId;

        var setHoverState = function setHoverState(state) {
          if (featureId) {
            _this4.map.setFeatureState({
              source: source,
              sourceLayer: sourceLayer,
              id: featureId
            }, {
              hover: state
            });
          }
        };

        var mousemove = function mousemove(e) {
          var f = e.features[0];

          if (f && f.id === featureId) {
            return;
          }

          setHoverState(false);
          if (!f) return;

          if (featureId && leaveCb) {
            leaveCb(_objectSpread2(_objectSpread2({}, e), {}, {
              oldFeatureId: featureId
            }));
          }

          featureId = f.id;
          setHoverState(true);

          if (enterCb) {
            enterCb(e);
          }
        };

        var mouseleave = function mouseleave(e) {
          setHoverState(false);

          if (e && e.oldFeatureId) {
            e.oldFeatureId = featureId;
          }

          featureId = undefined;

          if (leaveCb) {
            leaveCb(e);
          }
        };

        this.map.on('mousemove', layer, mousemove);
        this.map.on('mouseleave', layer, mouseleave);
        return function () {
          _this4.map.off('mousemove', layer, mousemove);

          _this4.map.off('mouseleave', layer, mouseleave);

          mouseleave();
        };
      }));

      _defineProperty(this, "clickLayer", arrayifyAndOff(function (layer, cb) {
        var _this5 = this;

        var click = function click(e) {
          e.features = _this5.map.queryRenderedFeatures(e.point, {
            layers: [layer]
          });
          cb(e);
        };

        this.map.on('click', layer, click);
        return function () {
          return _this5.map.off('click', layer, click);
        };
      }));

      _defineProperty(this, "hoverLayer", arrayifyAndOff(function (layer, cb) {
        var _this6 = this;

        var click = function click(e) {
          e.features = _this6.map.queryRenderedFeatures(e.point, {
            layers: [layer]
          });
          cb(e);
        };

        this.map.on('click', layer, click);
        return function () {
          return _this6.map.off('click', layer, click);
        };
      }));

      _defineProperty(this, "removeLayer", arrayify(function (layer) {
        var swallowError = function swallowError(data) {
          if (!data.error.message.match(/does not exist/)) {
            console.error(data.error);
          }
        };

        this.map.once('error', swallowError);
        this.map.removeLayer(layer);
        this.map.off('error', swallowError);
      }));

      _defineProperty(this, "setProperty", arrayify(function (layer, prop, value) {
        var _this7 = this;

        if (_typeof(prop) === 'object') {
          Object.keys(prop).forEach(function (k) {
            return _this7.setProperty(layer, k, prop[k]);
          });
        } else {
          var kprop = kebabCase(prop);

          if (isPaintProp(kprop)) {
            this.map.setPaintProperty(layer, kprop, value);
          } else if (isLayoutProp(kprop)) {
            this.map.setLayoutProperty(layer, kprop, value);
          } else ;
        }
      }));

      _defineProperty(this, "setLayerStyle", arrayify(function (layer, style) {
        var _this8 = this;

        var clearProps = function clearProps() {
          var oldObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var newObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return Object.keys(oldObj).forEach(function (key) {
            if (!(key in newObj)) {
              _this8.setProperty(layer, key, undefined);
            }
          });
        };

        if (_typeof(layer) === 'object' && !Array.isArray(layer) && layer.id && !style) {
          style = layer; // $FlowFixMe[incompatible-type]
          // $FlowFixMe[prop-missing]

          layer = style.id;
        }

        var oldStyle = this.getLayerStyle(layer);
        var newStyle = this.properties(style);
        clearProps(oldStyle.paint, newStyle.paint);
        clearProps(oldStyle.layout, newStyle.layout); // Hmm, this gets murky, what exactly is meant to happen with non-paint, non-layout props?

        this.setProperty(layer, _objectSpread2(_objectSpread2({}, newStyle.paint), newStyle.layout));
      }));

      _defineProperty(this, "show", arrayify(function (layer) {
        this.setVisibility(layer, 'visible');
      }));

      _defineProperty(this, "hide", arrayify(function (layer) {
        this.setVisibility(layer, 'none');
      }));

      _defineProperty(this, "toggle", arrayify(function (layer, state) {
        this.setVisibility(layer, state ? 'visible' : 'none');
      }));

      _defineProperty(this, "showSource", arrayify(function (source) {
        this.setVisibility(this.layersBySource(source), 'visible');
      }));

      _defineProperty(this, "hideSource", arrayify(function (source) {
        this.setVisibility(this.layersBySource(source), 'none');
      }));

      _defineProperty(this, "toggleSource", arrayify(function (sourceId, state) {
        this.setVisibility(this.layersBySource(sourceId), state ? 'visible' : 'none');
      }));

      _defineProperty(this, "setFilter", arrayify(function (layer, filter) {
        this.map.setFilter(layer, filter);
      }));

      _defineProperty(this, "removeSource", arrayify(function (source) {
        // remove layers that use this source first
        var layers = this.layersBySource(source);
        this.removeLayer(layers);

        if (this.map.getSource(source)) {
          this.map.removeSource(source);
        }
      }));

      _defineProperty(this, "setLayerSource", arrayify(function (layerId, source, sourceLayer) {
        var oldLayers = this.map.getStyle().layers;
        var layerIndex = oldLayers.findIndex(function (l) {
          return l.id === layerId;
        });
        var layerDef = oldLayers[layerIndex];
        var before = oldLayers[layerIndex + 1] && oldLayers[layerIndex + 1].id;
        layerDef.source = source;

        if (sourceLayer) {
          layerDef['source-layer'] = sourceLayer;
        } else if (sourceLayer !== undefined) {
          delete layerDef['source-layer'];
        }

        this.map.removeLayer(layerId);

        this._mapAddLayerBefore(layerDef, before);
      }));
    }

    _createClass(MapGlUtils, [{
      key: "hoverPointer",
      value:
      /** Sets Map's cursor to 'pointer' whenever the mouse is over these layers.
          @returns A function to remove the handler.
       */
      function hoverPointer(layerOrLayers) {
        var _this9 = this;

        var layers = resolveArray(layerOrLayers, this.map);

        var mouseenter = function mouseenter(e) {
          return _this9.map.getCanvas().style.cursor = 'pointer';
        };

        var mouseleave = function mouseleave(e) {
          // don't de-hover if we're still over a different relevant layer
          if (_this9.map.queryRenderedFeatures(e.point, {
            layers: layers
          }).length === 0) {
            _this9.map.getCanvas().style.cursor = oldCursor;
          }
        };

        var oldCursor = this.map.getCanvas().style.cursor;

        var _iterator = _createForOfIteratorHelper(layers),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var layer = _step.value;
            this.map.on('mouseleave', layer, mouseleave);
            this.map.on('mouseenter', layer, mouseenter);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return function () {
          var _iterator2 = _createForOfIteratorHelper(layers),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var layer = _step2.value;

              _this9.map.off('mouseenter', layer, mouseenter);

              _this9.map.off('mouseleave', layer, mouseleave);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          _this9.map.getCanvas().style.cursor = oldCursor;
        };
      }
      /**
      Updates feature-state of features in the connected source[s] whenever hovering over a feature in these layers.
      @param layer Layer(s) to add handler to.
      @param {string|Array} [source] Source whose features will be updated. If not provided, use the source defined for the layer.
      @param {string} [sourceLayer] Source layer (if using vector source)
      */

    }, {
      key: "hoverPopup",
      value:
      /** Show a popup whenever hovering over a feature in these layers.
      @param {string|Array<string>|RegExp|function} layers Layers to attach handler to.
      @param htmlFunc Function that receives feature and popup, returns HTML.
      @param {Object<PopupOptions>} popupOptions Options passed to `Popup()` to customise popup.
      @example hoverPopup('mylayer', f => `<h3>${f.properties.Name}</h3> ${f.properties.Description}`, { anchor: 'left' });
      */
      function hoverPopup(layers, htmlFunc) {
        var popupOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        if (!this._mapgl) {
          throw 'Mapbox GL JS or MapLibre GL JS object required when initialising';
        }

        var popup = new this._mapgl.Popup(_objectSpread2({
          closeButton: false
        }, popupOptions));
        return arrayifyAndOff(function (layer, htmlFunc) {
          var _this10 = this;

          var mouseenter = function mouseenter(e) {
            if (e.features[0]) {
              popup.setLngLat(e.lngLat);
              popup.setHTML(htmlFunc(e.features[0], popup));
              popup.addTo(_this10.map);
            }
          };

          var mouseout = function mouseout(e) {
            popup.remove();
          };

          this.map.on('mouseenter', layer, mouseenter);
          this.map.on('mouseout', layer, mouseout);
          return function () {
            _this10.map.off('mouseenter', layer, mouseenter);

            _this10.map.off('mouseout', layer, mouseout);

            mouseout();
          };
        }).call(this, layers, htmlFunc);
      }
      /** Show a popup whenever a feature in these layers is clicked.
          @param {string|Array<string>|RegExp|function} layers Layers to attach handler to.
          @param htmlFunc Function that receives feature and popup, returns HTML.
          @param {Object<PopupOptions>} popupOptions Options passed to `Popup()` to customise popup.
           @returns A function that removes the handler.
          @example clickPopup('mylayer', f => `<h3>${f.properties.Name}</h3> ${f.properties.Description}`, { maxWidth: 500 });
       */

    }, {
      key: "clickPopup",
      value: function clickPopup(layers, htmlFunc) {
        var popupOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        if (!this._mapgl) {
          throw 'Mapbox GL JS or Maplibre GL JS object required when initialising';
        }

        var popup = new this._mapgl.Popup(_objectSpread2({}, popupOptions));
        return arrayifyAndOff(function (layer, htmlFunc) {
          var _this11 = this;

          var click = function click(e) {
            if (e.features[0]) {
              popup.setLngLat(e.features[0].geometry.coordinates.slice());
              popup.setHTML(htmlFunc(e.features[0], popup));
              popup.addTo(_this11.map);
            }
          };

          this.map.on('click', layer, click);
          return function () {
            return _this11.map.off('click', layer, click);
          };
        }).call(this, layers, htmlFunc);
      }
      /** Fire a callback whenever a feature in these layers is clicked.
          @param {string|Array<string>|RegExp|function} layers Layers to attach handler to.
          @param {function} cb Callback that receives event with .features property
          @returns A function that removes the handler.
      */

    }, {
      key: "clickOneLayer",
      value:
      /**
      Detects a click in the first of a series of layers given, and fires a callback.
      @param {string|Array<string>|RegExp|function} layers Layers to attach handler to.
      @param cb Callback, receives `{ event, layer, feature, features }`.
      @param noMatchCb Callback when a click happens that misses all these layers. Receives `{ event }`.
      @returns A function to remove the handler.
      */
      function clickOneLayer(layerRef, cb, noMatchCb) {
        var _this12 = this;

        var layers = resolveArray(layerRef, this.map);

        var click = function click(e) {
          var match = false;

          var _iterator3 = _createForOfIteratorHelper(layers),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var layer = _step3.value;

              var features = _this12.map.queryRenderedFeatures(e.point, {
                layers: [layer]
              });

              if (features[0]) {
                try {
                  cb({
                    event: e,
                    layer: layer,
                    feature: features[0],
                    features: features
                  });
                } finally {
                  match = true;
                  break;
                }
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          if (!match && noMatchCb) {
            noMatchCb(e);
          }
        };

        this.map.on('click', click);
        return function () {
          return _this12.map.off('click', click);
        };
      }
      /**
      Fires a callback when mouse hovers over a feature in these layers.
      @param {string|Array<string>|RegExp|function} layers Layers to attach handler to.
      @returns A function to remove the handler.
      */

    }, {
      key: "_mapAddLayerBefore",
      value: function _mapAddLayerBefore(layerDef, beforeLayerId) {
        if (beforeLayerId) {
          this.map.addLayer(layerDef, beforeLayerId);
        } else {
          this.map.addLayer(layerDef);
        }
      }
      /** Adds a layer, given an id, source, type, and properties.
       */

    }, {
      key: "addLayer",
      value: function addLayer(id, source, type, props, before) {
        this._mapAddLayerBefore(this.layerStyle(id, source, type, props), before);

        return this._makeSource(source);
      } // TODO deprecate/remove?

    }, {
      key: "add",
      value: function add(id, source, type, props, before) {
        this._mapAddLayerBefore( // $FlowFixMe// technically this doesn't work for layer of type 'background'
        _objectSpread2(_objectSpread2({}, this.properties(props)), {}, {
          id: id,
          type: type,
          source: parseSource(source)
        }), before);

        if (typeof source === 'string') {
          return this._makeSource(source);
        }
      }
    }, {
      key: "setLayer",
      value: function setLayer(layerId, source, type, props, before) {
        var layerDef = this.layerStyle(layerId, source, type, props);
        var style = this.map.getStyle();
        var layerIndex = style.layers.findIndex(function (l) {
          return l.id === layerDef.id;
        });
        style.layers.findIndex(function (l) {
          return l.id === before;
        });

        {
          if (layerIndex >= 0) {
            this.map.removeLayer(layerDef.id);
            var readdBefore = before;

            if (!before && style.layers[layerIndex + 1]) {
              readdBefore = style.layers[layerIndex + 1].id;
            }

            this.map.addLayer(layerDef, readdBefore);
          } else {
            this.map.addLayer(layerDef, before || undefined);
          }
        }

        return this._makeSource(source);
      }
    }, {
      key: "addLineLayer",
      value: // The bodies of these functions are added later by `makeAddLayer`

      /** Adds a layer of type `line`.*/
      function addLineLayer(id, props, before) {}
      /** Adds a layer of type `fill`.*/

    }, {
      key: "addFillLayer",
      value: function addFillLayer(id, props, before) {}
      /** Adds a layer of type `circle`.*/

    }, {
      key: "addCircleLayer",
      value: function addCircleLayer(id, props, before) {}
      /** Adds a layer of type `symbol`.*/

    }, {
      key: "addSymbolLayer",
      value: function addSymbolLayer(id, props, before) {}
      /** Adds a layer of type `video`.*/

    }, {
      key: "addVideoLayer",
      value: function addVideoLayer(id, props, before) {}
      /** Adds a layer of type `raster`.*/

    }, {
      key: "addRasterLayer",
      value: function addRasterLayer(id, props, before) {}
      /** Adds a layer of type `fill-extrusion`.*/

    }, {
      key: "addFillExtrusionLayer",
      value: function addFillExtrusionLayer(id, props, before) {}
      /** Adds a layer of type `heatmap`.*/

    }, {
      key: "addHeatmapLayer",
      value: function addHeatmapLayer(id, props, before) {}
      /** Adds a layer of type `hillshade`.*/

    }, {
      key: "addHillshadeLayer",
      value: function addHillshadeLayer(id, props, before) {}
      /** Create a GeoJSON layer. */

    }, {
      key: "addGeoJSONSource",
      value: function addGeoJSONSource(id) {
        var geojson = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          type: 'FeatureCollection',
          features: []
        };
        var props = arguments.length > 2 ? arguments[2] : undefined;
        return this.addSource(id, _objectSpread2({
          type: 'geojson',
          data: geojson
        }, props));
      }
    }, {
      key: "addGeoJSON",
      value: function addGeoJSON(id) {
        var geojson = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          type: 'FeatureCollection',
          features: []
        };
        var props = arguments.length > 2 ? arguments[2] : undefined;
        return this.addGeoJSONSource(id, geojson, props);
      }
    }, {
      key: "addSource",
      value: function addSource(id, sourceDef) {
        var style = this.map.getStyle();
        style.sources[id] = sourceDef;
        this.map.setStyle(style);
        return this._makeSource(id);
      }
    }, {
      key: "layersBySource",
      value: function layersBySource(source) {
        return this.map.getStyle().layers.filter(function (l) {
          return l.source === source;
        }).map(function (l) {
          return l.id;
        });
      }
      /** Adds a `vector` source
      @param sourceId ID of the new source.
      @param {string} [data] Optional URL of source tiles (.../{z}/{x}/{y}...), mapbox:// URL or TileJSON endpoint.
      @param {object} props Properties defining the source, per the style spec.
       @example addVector('mysource', 'http://example.com/tiles/{z}/{x}/{y}.pbf', { maxzoom: 13 });
      */

    }, {
      key: "addVectorSource",
      value: function addVectorSource(sourceId, props) {
        var extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        if (typeof props === 'string') {
          if (props.match(/\{z\}/)) {
            return this.addSource(sourceId, _objectSpread2(_objectSpread2({}, extraProps), {}, {
              type: 'vector',
              tiles: [props]
            }));
          } else {
            // mapbox://, http://.../index.json
            return this.addSource(sourceId, _objectSpread2(_objectSpread2({}, extraProps), {}, {
              type: 'vector',
              url: props
            }));
          }
        } else {
          return this.addSource(sourceId, _objectSpread2(_objectSpread2({}, props), {}, {
            type: 'vector'
          }));
        }
      }
    }, {
      key: "addVector",
      value: function addVector(sourceId, props) {
        var extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return this.addVectorSource(sourceId, props, extraProps);
      }
      /** Adds a `raster` source
      @param sourceId ID of the new source.
      @param {object} props Properties defining the source, per the style spec.
      */

    }, {
      key: "addRasterSource",
      value:
      /** Adds a `raster` source
      @param sourceId ID of the new source.
      @param {object} props Properties defining the source, per the style spec.
      */
      function addRasterSource(sourceId, props) {
        return this.addSource(sourceId, _objectSpread2(_objectSpread2({}, props), {}, {
          type: 'raster'
        }));
      }
      /** Adds an `image` source
      @param sourceId ID of the new source.
      @param {object} props Properties defining the source, per the style spec.
      */

    }, {
      key: "addRasterDemSource",
      value:
      /** Adds a `raster-dem` source
      @param sourceId ID of the new source.
      @param {object} props Properties defining the source, per the style spec.
      */
      function addRasterDemSource(sourceId, props) {
        return this.addSource(sourceId, _objectSpread2(_objectSpread2({}, props), {}, {
          type: 'raster-dem'
        }));
      }
    }, {
      key: "addImageSource",
      value: function addImageSource(sourceId, props) {
        return this.addSource(sourceId, _objectSpread2(_objectSpread2({}, props), {}, {
          type: 'image'
        }));
      }
      /** Adds a `video` source
      @param sourceId ID of the new source.
      @param {object} props Properties defining the source, per the style spec.
      */

    }, {
      key: "addVideoSource",
      value: function addVideoSource(sourceId, props) {
        return this.addSource(sourceId, _objectSpread2(_objectSpread2({}, props), {}, {
          type: 'video'
        }));
      }
      /** Sets a paint or layout property on one or more layers.
      @example setProperty(['buildings-fill', 'parks-fill'], 'fillOpacity', 0.5)
      */

    }, {
      key: "properties",
      value:
      /** Converts a set of properties in pascalCase or kebab-case into a layer objectwith layout and paint properties. */
      function properties(props) {
        if (!props) {
          return undefined;
        }

        var out = {},
            which = {
          paint: {},
          layout: {},
          other: {}
        };
        Object.keys(props).forEach(function (prop) {
          var kprop = kebabCase(prop);
          which[whichProp(kprop)][kprop] = props[prop];
        });

        if (Object.keys(which.paint).length) {
          out.paint = which.paint;
        }

        if (Object.keys(which.layout).length) {
          out.layout = which.layout;
        }

        Object.assign(out, which.other);
        return out;
      } // layerStyle([id,] [source,] [type,] props)
      // TODO somehow make this type safe.

    }, {
      key: "layerStyle",
      value: function layerStyle() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        var id = args[0],
            source = args[1],
            type = args[2];
        var props = args.find(function (arg) {
          return _typeof(arg) === 'object' && !Array.isArray(arg);
        });
        var ret = _typeof(props) === 'object' ? this.properties(props) || {} : {};
        if (typeof id === 'string') ret.id = id;
        if (typeof source === 'string') ret.source = source;
        if (typeof type === 'string') ret.type = type;
        return ret;
      }
      /** Gets the layer definition for a given layer id, as per the style spec..
       */

    }, {
      key: "getLayerStyle",
      value: function getLayerStyle(layerId) {
        return this.map.getStyle().layers.find(function (l) {
          return l.id === layerId;
        });
      }
    }, {
      key: "setData",
      value:
      /** Replaces the current data for a GeoJSON layer.
      @param sourceId Id of the source being updated.
      @param {GeoJSON} [data] GeoJSON object to set. If not provided, defaults to an empty FeatureCollection.
      */
      function setData(sourceId) {
        var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          type: 'FeatureCollection',
          features: []
        };
        this.map.getSource(sourceId).setData(data);
      }
      /** Makes the given layers visible.
      @param {string|Array<string>|RegExp|function} Layer to toggle.
      */

    }, {
      key: "onLoad",
      value:
      /** Callback that fires when map loads, or immediately if map is already loaded.
      @returns {Promise} Promise, if callback not provided.
      */
      function onLoad(cb) {
        var _this13 = this;

        if (!cb) {
          return new Promise(function (resolve) {
            return _this13.onLoad(resolve);
          });
        } else {
          if (this.map.loaded() || this._loaded) {
            cb();
          } else {
            this.map.once('load', function () {
              _this13._loaded = true;
              cb();
            });
          }
        }
      }
      /** Set a property on the style's root, such as `light` or `transition`. */

    }, {
      key: "setRootProperty",
      value: function setRootProperty(propName, val) {
        var style = this.map.getStyle();
        style[kebabCase(propName)] = val;
        this.map.setStyle(style);
      }
      /** Sets root transition property.
      @example setTransition({ duration: 500, delay: 100 })
      */

    }, {
      key: "setTransition",
      value: function setTransition(val) {
        this.setRootProperty('transition', val);
      }
      /** Adds an image for use as a symbol layer, from a URL.
      @example loadImage('marker', '/assets/marker-pin@2x.png', { pixelRatio: 2})
      */

    }, {
      key: "loadImage",
      value: function loadImage(id, url, options) {
        var _this14 = this;

        if (typeof url === 'string'
        /* && url.match(/\.[a-z]+$/)*/
        ) {
            return new Promise(function (resolve, reject) {
              _this14.map.loadImage(url, function (error, image) {
                if (error) {
                  console.error("Error loading image ".concat(url), error);
                  reject("Error loading image ".concat(url));
                } else {
                  _this14.map.addImage(id, image, options);

                  resolve(id);
                }
              });
            });
          } else {
          return this.map.addImage(id, url, options);
        }
      }
    }, {
      key: "lockOrientation",
      value: function lockOrientation() {
        this.map.touchZoomRotate.disableRotation();
        this.map.dragRotate.disable();
      }
      /** Gets array of font names in use, determined by traversing style. Does not detect fonts in all possible situations.
      @returns {Array[string]}  */

    }, {
      key: "fontsInUse",
      value: function fontsInUse() {
        // TODO add tests
        // TODO: find fonts burried within ['format', ... { 'text-font': ... }] expressions
        function findLiterals(expr) {
          if (Array.isArray(expr)) {
            if (expr[0] === 'literal') {
              ///
              fonts.push.apply(fonts, _toConsumableArray(expr[1]));
            } else {
              expr.forEach(findLiterals);
            }
          }
        }

        var fonts = [];
        var fontExprs = this.map.getStyle().layers.map(function (l) {
          return l.layout && l.layout['text-font'];
        }).filter(Boolean);

        var _iterator4 = _createForOfIteratorHelper(fontExprs),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var fontExpr = _step4.value;

            // if top level expression is an array of strings, it's hopefully ['Arial', ...] and not ['get', 'font']
            if (fontExpr.stops) {
              // old-school base/stops
              // TODO verify we have got all the cases
              try {
                fonts.push.apply(fonts, _toConsumableArray(fontExpr.stops.flat().filter(Array.isArray).flat()));
              } catch (_unused) {
                console.log("Couldn't process font expression:", fontExpr);
              }
            } else if (fontExpr.every(function (f) {
              return typeof f === 'string';
            })) {
              fonts.push.apply(fonts, _toConsumableArray(fontExpr));
            } else {
              findLiterals(fontExpr);
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        return _toConsumableArray(new Set(fonts));
      }
    }, {
      key: "_makeSource",
      value: function _makeSource(sourceId) {
        // returns an object on which we can call .addLine() etc.
        var out = new MapGlUtils();
        out.map = this.map;
        out._mapgl = this._mapgl;
        layerTypes.forEach(function (type) {
          makeAddLayer(type, out, sourceId);
        });
        return out;
      }
    }], [{
      key: "init",
      value:
      /** Initialises Map-GL-Utils on existing map object.
          @param mapgl Mapbox-GL-JS or Maplibre-GL-JS library. Only needed for later use by `hoverPopup()` etc.
          @returns Initialised MapGlUtils object.
      */
      function init(map, mapgl) {
        map.U = new MapGlUtils();
        map.U._mapgl = mapgl;
        map.U.map = map;
        return map.U;
      }
    }, {
      key: "newMap",
      value: function () {
        var _newMap = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(mapboxgl) {
          var params,
              options,
              addLayers,
              addSources,
              transformStyle,
              mixStyles,
              styleParam,
              style,
              styleUrl,
              response,
              u,
              map,
              _args = arguments;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  mixStyles = function _mixStyles(style) {
                    var _this16 = this;

                    var mixStyles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    Object.keys(mixStyles).forEach(function (sourceId) {
                      var layers = mixStyles[sourceId].layers;
                      delete mixStyles[sourceId].layers;
                      style.sources[sourceId] = mixStyles[sourceId];
                      style.layers = [].concat(_toConsumableArray(style.layers), _toConsumableArray(layers.map(function (l) {
                        return _this16.layerStyle(_objectSpread2({
                          source: sourceId
                        }, l));
                      })));
                    });
                  };

                  transformStyle = function _transformStyle(style) {
                    var transformFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (StyleSpecification) {
                      return StyleSpecification;
                    };
                    style = transformFunc(style);
                  };

                  addSources = function _addSources(style) {
                    var sources = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    // sources don't need any special treatment?
                    style.sources = _objectSpread2(_objectSpread2({}, style.sources), sources);
                  };

                  addLayers = function _addLayers(style) {
                    var _this15 = this;

                    var layers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
                    style.layers = [].concat(_toConsumableArray(style.layers), _toConsumableArray(layers.map(function (l) {
                      return _this15.layerStyle(l);
                    })));
                  };

                  params = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                  options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};

                  if (!params.style) {
                    params.style = {
                      version: 8,
                      layers: [],
                      sources: {}
                    };
                  }

                  if (!(options.addLayers || options.addSources || options.transformStyle || options.mixStyles)) {
                    _context.next = 26;
                    break;
                  }

                  styleParam = params.style;

                  if (!(typeof styleParam === 'string')) {
                    _context.next = 19;
                    break;
                  }

                  styleUrl = styleParam.replace(/^mapbox:\/\/styles\//, 'https://api.mapbox.com/styles/v1/');
                  _context.next = 13;
                  return fetch(styleUrl);

                case 13:
                  response = _context.sent;
                  _context.next = 16;
                  return response.json();

                case 16:
                  style = _context.sent;
                  _context.next = 20;
                  break;

                case 19:
                  style = styleParam;

                case 20:
                  u = new MapGlUtils();
                  addLayers.call(u, style, options.addLayers);
                  addSources(style, options.addSources);
                  transformStyle(style, options.transformStyle);
                  mixStyles.call(u, style, options.mixStyles);
                  params.style = style;

                case 26:
                  map = new mapboxgl.Map(params);
                  MapGlUtils.init(map, mapboxgl);
                  return _context.abrupt("return", map);

                case 29:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function newMap(_x) {
          return _newMap.apply(this, arguments);
        }

        return newMap;
      }()
    }]);

    return MapGlUtils;
  }(); // idempotent version


  var makeAddLayer = function makeAddLayer(layerType, obj, fixedSource) {
    var func;

    if (fixedSource) {
      func = function func(id, options, before) {
        return this.setLayer(id, fixedSource, layerType, options, before);
      };
    } else {
      func = function func(id, source, options, before) {
        return this.setLayer(id, source, layerType, options, before);
      };
    }

    var upType = upperCamelCase(layerType); //$FlowFixMe[prop-missing]

    obj["add".concat(upType)] = func; //$FlowFixMe[prop-missing]

    obj["add".concat(upType, "Layer")] = func;
  }; // Object.assign(Utils.prototype, UtilsExtra);


  function initClass(U) {
    var makeSetProp = function makeSetProp(prop, setPropFunc) {
      var funcName = 'set' + upperCamelCase(prop); //$FlowFixMe[prop-missing]

      U[funcName] = arrayify(function (layer, value) {
        return this.map[setPropFunc](layer, prop, value);
      });
    };

    var makeGetProp = function makeGetProp(prop, getPropFunc) {
      var funcName = 'get' + upperCamelCase(prop); //$FlowFixMe[prop-missing]

      U[funcName] = arrayify(function (layer) {
        return this.map[getPropFunc](layer, prop);
      });
    };


    U.update = U.setData; // deprecated
    // Turn every property into a 'setTextSize()', 'setLineColor()' etc.

    allProps.paints.forEach(function (prop) {
      return makeSetProp(prop, 'setPaintProperty');
    });
    allProps.layouts.forEach(function (prop) {
      return makeSetProp(prop, 'setLayoutProperty');
    });
    allProps.paints.forEach(function (prop) {
      return makeGetProp(prop, 'getPaintProperty');
    });
    allProps.layouts.forEach(function (prop) {
      return makeGetProp(prop, 'getLayoutProperty');
    });
    layerTypes.forEach(function (layerType) {
      return makeAddLayer(layerType, U);
    });
  }

  var U = MapGlUtils.prototype;
  initClass(U);

  return MapGlUtils;

})));
